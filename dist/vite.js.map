{"version":3,"file":"vite.js","names":["file: string","routesDir: string","dir: string","extensions: string[]","files: string[]","directory: string","filename: string","config: ResolvedConfig","pluginConfig: PackframePluginOptions","routes","routePath: string","routes: RouteConfig[]","route: RouteConfig","route: RouteFile","p: string","options?: PackframePluginOptions","config: ResolvedConfig","routeCache: RouteFile[] | null","resolvedConfig: ResolvedConfig","server: ViteDevServer","file: string","source: string","_importer: string | undefined","ops: { ssr?: boolean }","id: string","ops?: { ssr?: boolean }"],"sources":["../src/helpers/fs-helpers.ts","../src/vite/index.ts"],"sourcesContent":["// import { normalizePath } from \"vite\";\nimport { dirname, join, posix, win32 } from \"node:path\";\nimport { existsSync } from \"node:fs\";\nimport { readdir } from \"node:fs/promises\";\nimport type { ResolvedConfig } from \"vite\";\nimport type { PackframePluginOptions } from \"../vite/types\";\nimport type { RouteConfig, RouteFile } from \"../router/types\";\n\n/**\n * Get the file most probable route path for a given potential route.\n */\nexport const fileToRoute = (file: string, routesDir: string) => {\n  const cleanPath = file\n    .slice(routesDir.length + 1) // also remove initial slash\n    .replace(/\\.(jsx|tsx|ts|js)$/, \"\")\n    .replace(/index$/, \"\")\n    .replace(/\\(.*\\)$/, \"\") // Remove (file_name) from path\n    .replace(/\\([^)]+\\)\\/?/g, \"\") // Remove (folder_name) from path\n    .replace(/\\[\\.\\.\\.[^\\]]+\\]/g, \"*\")\n    .replace(/\\[([^\\]]+)\\]/g, \":$1\");\n  const slashPath = cleanPath.endsWith(\"/\")\n    ? cleanPath.slice(0, -1)\n    : cleanPath;\n  const path = slashPath === \"*\"\n    ? slashPath\n    : slashPath?.length > 0\n    ? `/${slashPath}`\n    : \"/\";\n\n  return path;\n};\n\n/**\n * Identify all files in a folder.\n */\nexport const globFiles = async (dir: string, extensions: string[]) => {\n  const files: string[] = [];\n\n  async function scan(directory: string) {\n    if (!existsSync(directory)) {\n      // console.log('  ➜  pakframe/router: the \"routes\" folder does not exist.');\n      return;\n    }\n    const entries = await readdir(directory, { withFileTypes: true });\n    if (!entries.length) {\n      // console.warn('  ➜  pakframe/router: the \"routes\" folder is empty.');\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = join(directory, entry.name);\n\n      // istanbul ignore else\n      if (entry.isDirectory()) {\n        await scan(fullPath);\n      } else if (entry.isFile()) {\n        // Check if file has allowed extension\n        // istanbul ignore else\n        if (extensions.some((ext) => entry.name.endsWith(ext))) {\n          files.push(fullPath);\n        }\n      }\n    }\n  }\n\n  await scan(dir);\n  return files;\n};\n\nconst normalizePathRegExp = new RegExp(`\\\\${win32.sep}`, \"g\");\nfunction normalizePath(filename: string) {\n  return filename.replace(normalizePathRegExp, posix.sep);\n}\n\n/**\n * Scan routes directory and generate routes.\n */\nexport const scanRoutes = async (\n  config: ResolvedConfig,\n  pluginConfig: PackframePluginOptions,\n) => {\n  const { routesDir, extensions } = pluginConfig;\n  const routesPath = join(config.root!, routesDir);\n  const files = await globFiles(routesPath, extensions);\n\n  if (!files?.length) {\n    return [];\n  }\n\n  // Filter out duplicate routes and layout files that are already used\n  const routes = files.map((file) => ({\n    path: normalizePath(file),\n    routePath: fileToRoute(file, routesPath),\n  }));\n\n  // Remove duplicate routes (prefer non-layout files)\n  const uniqueRoutes = routes.reduce(\n    (acc, route) => {\n      const existing = acc.find((r) => r.routePath === route.routePath);\n      if (\n        !existing || (existing.path.includes(\"(\") && !route.path.includes(\"(\"))\n      ) {\n        // Remove the existing route if this is a better match\n        // istanbul ignore if - should not be possible\n        if (existing) {\n          acc = acc.filter((r) => r !== existing);\n        }\n        acc.push(route);\n      }\n      return acc;\n    },\n    [] as typeof routes,\n  );\n\n  return uniqueRoutes;\n};\n\n/**\n * Find all layout files for a given route.\n */\nexport const findLayouts = (\n  routePath: string,\n  config: ResolvedConfig,\n  pluginConfig: PackframePluginOptions,\n) => {\n  const { routesDir, extensions } = pluginConfig;\n  const layouts = [];\n  let dir = dirname(routePath);\n  const routesPath = join(config.root as string, routesDir);\n\n  // Walk up the directory tree looking for layout files\n  while (dir.startsWith(routesPath) && dir !== routesPath) { // Stop at routes dir\n    let layoutFile = null;\n    const dirName = dir.split(/[/\\\\]/).pop();\n\n    // istanbul ignore else\n    if (dirName) {\n      // Look for a layout file in the current directory\n      for (const ext of extensions) {\n        const layoutPaths = [\n          join(dirname(dir), `${dirName}${ext}`),\n          join(dirname(dir), `(${dirName.replace(/^\\((.*)\\)$/, \"$1\")})${ext}`),\n        ];\n\n        for (const path of layoutPaths) {\n          if (existsSync(path)) {\n            layoutFile = path;\n            break;\n          }\n        }\n      }\n    }\n\n    // istanbul ignore else\n    if (layoutFile && layoutFile !== routePath) {\n      layouts.unshift({\n        id: `Layout${layouts.length}`,\n        path: layoutFile,\n      });\n    }\n\n    dir = dirname(dir);\n  }\n\n  return layouts;\n};\n\nexport const processLayoutRoutes = (\n  routes: RouteConfig[],\n  config: ResolvedConfig,\n  pluginConfig: PackframePluginOptions,\n) => {\n  if (!routes.length) return [];\n\n  return routes.map((route) => {\n    const layouts = findLayouts(route.path, config, pluginConfig);\n    return {\n      ...route,\n      layouts,\n    };\n  });\n};\n\n/**\n * Scan and process routes and return them\n */\nexport const getRoutes = async (\n  config: ResolvedConfig,\n  pluginConfig: PackframePluginOptions,\n) => {\n  const routes = await scanRoutes(config, pluginConfig);\n  return processLayoutRoutes(routes, config, pluginConfig);\n};\n\nexport const generateRouteProloaders = (route: RouteConfig) => {\n  const moduleName = \"PageModule\";\n  const layoutName = \"Module\";\n\n  return `{\n    preload: async (params) => {\n      ${\n    route.layouts?.map((layout) =>\n      `if (${layout.id + layoutName}?.route?.preload) await ${\n        layout.id + layoutName\n      }?.route?.preload(params);`\n    ).join(\"\\n      \")\n  }\n      if (${moduleName}?.route?.preload) await ${moduleName}?.route?.preload(params);\n    },\n    load: async (params) => {\n      ${\n    route.layouts?.map((layout) =>\n      `if (${layout.id + layoutName}?.route?.load) await ${\n        layout.id + layoutName\n      }?.route?.load(params);`\n    ).join(\"\\n      \")\n  }\n      if (${moduleName}?.route?.load) await ${moduleName}?.route?.load(params);\n    }\n  }`;\n};\n\nexport const generateComponentRoute = (route: RouteFile) => {\n  if (route.layouts?.length > 0) {\n    // Only generate imports for unique layouts\n    const layoutImports = route.layouts.map(\n      (layout) =>\n        `const ${layout.id}Module = await import('${JSON.stringify(layout.path)}');\\n` +\n        `const ${layout.id}Page = ${layout.id}Module.Layout || ${layout.id}Module.Page || ${layout.id}Module.default;`,\n    ).join(\"\\n\");\n\n    // Use both shared and unique layouts for the component chain\n    const pageComponent = route.layouts.reduce(\n      (acc, layout) => `${layout.id}Page({ children: ${acc} })`,\n      \"Page()\",\n    );\n\n    return `ROUTER.lazy(() => {\n      const importFn = async () => {\n        ${layoutImports}\n        const PageModule = await import('${JSON.stringify(route.path)}');\n        const Page = PageModule?.Page || PageModule?.default;\n  \n        return Promise.resolve({\n          route: ${generateRouteProloaders(route)},\n          Page: () => ${pageComponent},\n        });\n      };\n      return importFn();\n    })`;\n  }\n\n  return `ROUTER.lazy(() => import('${route.path}'))`;\n};\n\nexport const generateRoute = (route: RouteFile) => {\n  return `ROUTER.Route({\n    path: \"${JSON.stringify(route.routePath)}\",\n    component: ${generateComponentRoute(route)},\n  });`;\n};\n","import { fileURLToPath } from \"node:url\";\nimport { dirname, join, resolve } from \"node:path\";\n// import process from \"node:process\";\nimport {\n  type PluginOption,\n  type ResolvedConfig,\n  transformWithEsbuild,\n  type ViteDevServer,\n} from \"vite\";\n// import { routes } from \"../router/routes\";\n// import { routes } from \"pakframe/router\";\nimport { routes } from \"pakframe/router\";\nimport type { RouteFile } from \"../router/types\";\nimport { generateRoute, getRoutes } from \"../helpers/fs-helpers\";\nimport type { PackframePluginOptions } from \"./types\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nconst toAbsolute = (p: string) => resolve(__dirname, p);\n\n// console.log(toAbsolute(\"./router.js\"));\n\nconst pluginDefaults = {\n  routesDir: \"src/routes\",\n  extensions: [\".tsx\", \".jsx\", \".ts\", \".js\"],\n};\n\nfunction PackframePlugin(options?: PackframePluginOptions): PluginOption {\n  const pluginConfig = { ...pluginDefaults, ...options };\n  const { routesDir } = pluginConfig;\n\n  let config: ResolvedConfig;\n  let routeCache: RouteFile[] | null = null;\n\n  const routesVirtualModuleId = \"virtual:@pakframe/routes\";\n  const resolvedRoutesVirtualModuleId = \"\\0\" + routesVirtualModuleId;\n\n  const virtualSSRModuleId = \"virtual:@pakframe/ssr\";\n  const resolvedVirtualSSRModuleId = \"\\0\" + virtualSSRModuleId;\n\n  const virtualRouterModuleId = \"virtual:@pakframe/router\";\n  const resolvedVirtualRouterModuleId = \"\\0\" + virtualRouterModuleId;\n\n  return {\n    name: \"pakframe\",\n    enforce: \"pre\",\n    config() {\n      return {\n        // optimizeDeps: {\n        //   noDiscovery: true,\n        //   include: [\n        //     // \"pakframe\",\n        //     // \"pakframe/*\",\n        //     // \"pakframe/ssr\",\n        //     // \"pakframe/router\",\n        //     // \"pakframe/meta\",\n        //     // \"pakframe/jsx-runtime\",\n        //     // \"pakframe/jsx-dev-runtime\",\n        //     // \"virtual:@pakframe/*\"\n        //   ],\n        // },\n        ssr: {\n          noExternal: [\n            \"pakframe\",\n            \"pakframe/*\",\n            \"@core\",\n            \"@ssr\",\n            \"@router\",\n            \"@pakframe/*\", \n            /*\"pakframe/ssr\", \"pakframe/router\",*/\n            // \"virtual:@pakframe/routes\",\n            // \"virtual:@pakframe/*\"\n          ],\n          external: [\n            // \"virtual:@pakframe/routes\",\n            // \"virtual:@pakframe/router\",\n            // \"@pakframe/fs-routes\",\n          ]\n        },\n        resolve: {\n          alias: {\n            \"@ssr\": toAbsolute(\"ssr\"),\n            \"@core\": toAbsolute(\"index\"),\n            \"@router\": toAbsolute(\"router\"),\n            // \"@pakframe\": toAbsolute(\"./index.js\"),\n            // \"@pakframe/*\": toAbsolute(\"./\"),\n            // \"@pakframe/ssr\": toAbsolute(\"./ssr.js\"),\n            // \"@pakframe/router\": toAbsolute(\"../src/router/index.ts\"),\n            \"@pakframe/router\": fileURLToPath(new URL(\"./router.js\", import.meta.url)),\n            // \"@pakframe/router\": toAbsolute(\"./router\"),\n            // \"@pakframe/fs-routes\": toAbsolute(\"./\"),\n          },\n        },\n        esbuild: {\n          jsx: \"automatic\",\n          jsxImportSource: \"pakframe\",\n        },\n      };\n    },\n    configResolved(resolvedConfig: ResolvedConfig) {\n      config = resolvedConfig;\n    },\n\n    configureServer(server: ViteDevServer) {\n      // Watch routes directory\n      const pagesPath = join(config.root, routesDir);\n      const changeHandler = (file: string) => {\n        // istanbul ignore else\n        if (file.startsWith(pagesPath)) {\n          routes.length = 0;\n          routeCache = null;\n          const module = server.moduleGraph.getModuleById(\n            resolvedRoutesVirtualModuleId,\n          );\n          // istanbul ignore else\n          if (module) {\n            server.moduleGraph.invalidateModule(module);\n          }\n          server.ws.send({ type: \"full-reload\" });\n        }\n      };\n      server.watcher.add(pagesPath);\n\n      // Handle file changes in pages directory\n      // 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir'\n      server.watcher.on(\"add\", changeHandler);\n      server.watcher.on(\"addDir\", changeHandler);\n      server.watcher.on(\"unlink\", changeHandler);\n      server.watcher.on(\"unlinkDir\", changeHandler);\n      server.watcher.on(\"change\", changeHandler);\n    },\n    resolveId(\n      source: string,\n      _importer: string | undefined = undefined,\n      ops: { ssr?: boolean },\n    ) {\n      const ssr = ops?.ssr;\n      // Handle virtual module\n      if (source === routesVirtualModuleId) {\n        return resolvedRoutesVirtualModuleId;\n      }\n      if (source === virtualRouterModuleId) {\n        return resolvedVirtualRouterModuleId;\n      }\n      if (ssr && (source === \"pakframe\" || source === \"@core\")) {\n        return resolvedVirtualSSRModuleId;\n        // return \"pakframe/ssr\"\n      }\n      // if (source === \"pakframe/router\") {\n      //   return virtualRouterModuleId;\n      // }\n\n      return null;\n    },\n    async load(id: string, ops?: { ssr?: boolean }) {\n      // istanbul ignore else\n      if (id === resolvedVirtualSSRModuleId) {\n        // Dynamically load SSR content (replace with actual SSR logic)\n        return `\n          export * from 'pakframe/ssr';\n        `;\n      }\n      if (id === resolvedVirtualRouterModuleId) {\n        return `\n          export * from 'pakframe/router';\n        `;\n      }\n      // if (id === \"@pakframe/router\") {\n      //   // Dynamically load SSR content (replace with actual SSR logic)\n      //   return toAbsolute(\"./router.js\");\n      // }\n      // istanbul ignore else\n      if (id === resolvedRoutesVirtualModuleId) {\n        const currentRoutes = routeCache ||\n          await getRoutes(config, pluginConfig);\n        if (!currentRoutes || !currentRoutes.length) {\n          // don't crash the server if no routes are found\n          // devs might not use file system router\n          return { code: \"\", map: null };\n        }\n        // console.log(toAbsolute(\"./index.js\"))\n        const routesScript = `\n// import { signal } from \"pakframe/ssr\";\n// console.log({ signal });\n// import * as ROUTER from \"pakframe/router\";\nimport { Route, routes, lazy } from \"pakframe/router\";\n// const { Route, routes, lazy } = ROUTER;\n// import { Route } from \"pakframe/router/Route\";\n// import { routes } from \"pakframe/router/routes\";\n// import { lazy } from \"pakframe/router/lazy\";\n// import { Route, routes, lazy } from \"@router\";\n// import { Route, routes, lazy } from \"virtual:@pakframe/router\";\n// import { Route, routes, lazy } from \"@pakframe/router\";\n// import { Route, routes, lazy } from \"${toAbsolute(\"./router.js\")}\";\n// import { Route } from \"@pakframe/router/Route.js\";\n// import { routes } from \"@pakframe/router/routes.js\";\n// import { lazy } from \"@pakframe/router/lazy.js\";\nconsole.log({ Route, routes, lazy })\n// console.log({ ROUTER })\n\n// Reset current routes\n// if (ROUTER.routes) {\n//   ROUTER.routes.length = 0;\n// }\nif (routes) {\n  routes.length = 0;\n}\n\n// Register routes\n${currentRoutes.map(generateRoute).join(\"\\n\")}\n${\n          ops?.ssr && currentRoutes.length\n            ? `console.log(\\`  ➜  pakframe/router registered ${currentRoutes.length} routes.\\`)`\n            : /* istanbul ignore next - satisfied */ \"\"\n        }\n`;\n\n        const result = await transformWithEsbuild(\n          routesScript,\n          id,\n          { loader: \"js\" },\n        );\n\n        return {\n          code: result.code,\n          map: null,\n        };\n      }\n      return null;\n    },\n  };\n}\n\nexport { PackframePlugin as default };\n"],"mappings":"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"}