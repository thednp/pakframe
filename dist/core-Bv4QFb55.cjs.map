{"version":3,"file":"core-Bv4QFb55.cjs","names":["context: ContextEntry[]","running: ContextEntry","subscriptions: Set<ContextEntry>","fn: Accessor<T>","fn: () => void","value: T","nextValue: T | ((v: T) => T)","fn: ObserverFn","value: () => T","element: Element","key: string","rawValue?: PropValueOrAccessor","styleObject: T","key: keyof T","value: T[keyof T]","styleValue?: FunctionMaybe<CSSProperties | string | null | undefined>","target: DOMElement","namespaceElements: Record<string | symbol, string>","parent: DOMElement","child?:\n    | FunctionMaybe<RegExp | Date>\n    | Accessor<MaybeChildNode>\n    | MaybeChildNode\n    | Promise<MaybeChildNode>","tagName: K","target: DOMElement","event: K","handler:\n    & EventListenerObject[\"handleEvent\"]\n    & ((e: HTMLElementEventMap[K]) => void)","options?: AddEventListenerOptions","first?: MaybeChildNode | DOMNodeAttributes<PotentialProps<K>, K>","routes: RouteEntry[]","url?: string","isServer","path: string","search?: string","params?: Record<string, string>","pageName: string","component: ComponentFn | (() => LazyComponent)","isServer","params?: Record<string, string>","key: ImportFn","value: ComponentModule","importFn: ImportFn","isServer","module","component","routeProps: RouteProps","pattern: string","path: string","params: Record<string, string>","initialPath: string","initialPath","path: string","options: { replace: boolean }","isServer","newProps: Omit<DOMNodeAttributes<DOMTagNameMap[\"a\"], \"a\">, \"children\">","e: MouseEvent","module","source: FunctionMaybe<DOMElement | DOMElement[]>","attributeString: string","attributes: Record<string, string>","tag: Element","isServer","serverHeadTags: Map<string, SupportedHeadTags>","tag: SupportedHeadTags","props: DOMNodeAttributes<PotentialProps<\"title\">, \"title\">","content: string","props: DOMNodeAttributes<PotentialProps<\"meta\">, \"meta\">","props: DOMNodeAttributes<PotentialProps<\"link\">, \"link\">","props: DOMNodeAttributes<PotentialProps<\"script\">, \"script\">","props: DOMNodeAttributes<PotentialProps<\"style\">, \"style\">","isServer","module","component","e: Event","children","route","target: DOMElement","target: Element","content: DOMElement | DOMElement[] | Promise<DOMElement | DOMElement[]>","wrapper","item: Primitive | StoreObject","get: Accessor<(Primitive | StoreObject)[]>","set: Setter<(Primitive | StoreObject)[]>","current: Array<Primitive | StoreObject>","next: Array<Primitive | StoreObject>","obj: StoreObject","parentReceiver: StoreObject","store","init: T","props: ListProps<T>","parentElement: DOMElement","items: T[]","marker: DOMElement | Text"],"sources":["../src/core/state.ts","../src/core/attr.ts","../src/core/ns.ts","../src/core/h.ts","../src/router/routes.ts","../src/router/state.ts","../src/helpers/router-helpers.ts","../src/router/cache.ts","../src/router/lazy.ts","../src/router/Route.ts","../src/router/extractParams.ts","../src/router/matchRoute.ts","../src/router/navigate.ts","../src/router/A.ts","../src/router/unwrap.ts","../src/helpers/head-helpers.ts","../src/meta/Head.ts","../src/meta/tags.ts","../src/router/Router.ts","../src/core/hydrate.ts","../src/core/store.ts","../src/core/flow.ts"],"sourcesContent":["// src/state.ts\nimport { isFunction } from \"../util\";\nimport type { Accessor, ContextEntry, ObserverFn, Setter } from \"../types/types\";\n\nlet context: ContextEntry[] = [];\n\nfunction subscribe(running: ContextEntry, subscriptions: Set<ContextEntry>) {\n  subscriptions.add(running);\n  running.dependencies.add(subscriptions);\n}\n\n// Clear dependencies\nfunction cleanup(running: ContextEntry) {\n  for (const dep of running.dependencies) {\n    dep.delete(running);\n  }\n  running.dependencies.clear();\n}\n\n// Execute without effects\nexport function untrack<T>(fn: Accessor<T>) {\n  const tempContext = context;\n  context = [];\n  const value = fn();\n  context = tempContext;\n  return value;\n}\n\nexport function onMount(fn: () => void) {\n  let init = false;\n  effect(() => {\n    if (init) return;\n    init = true;\n    fn();\n    return () => {};\n  });\n}\n\nexport function signal<T>(value: T) {\n  value = isFunction(value) ? value() : value;\n  const subscriptions = new Set<ContextEntry>();\n\n  return [\n    () => {\n      const running = context[context.length - 1];\n      if (running) {\n        subscribe(running, subscriptions);\n      }\n      return value;\n    },\n    (nextValue: T | ((v: T) => T)) => {\n      if (isFunction(nextValue)) {\n        value = nextValue(value);\n      } else {\n        value = nextValue;\n      }\n\n      // Create a new array from subscriptions to avoid mutation during iteration\n      const subs = Array.from(subscriptions);\n      for (const sub of subs) {\n        sub.execute();\n      }\n    },\n  ] as [Accessor<T>, Setter<T>];\n}\n\nexport function effect(fn: ObserverFn) {\n  let running: ContextEntry;\n  const execute = () => {\n    cleanup(running);\n    context.push(running);\n    try {\n      const result = fn();\n      // Handle cleanup function returned from effect\n      if (typeof result === \"function\") {\n        cleanup(running); // Clear previous cleanup\n        running.cleanup = result;\n      }\n    } finally {\n      context.pop();\n    }\n  };\n\n  running = {\n    execute,\n    dependencies: new Set(),\n    cleanup: undefined, // Add cleanup property\n  };\n\n  execute();\n\n  // Return dispose function\n  return () => {\n    cleanup(running);\n    if (running.cleanup) {\n      running.cleanup();\n    }\n  };\n}\n\nexport function memo<T>(value: () => T) {\n  const [get, set] = signal<T | null>(null);\n  effect(() => set(value()));\n  return get;\n}\n","import type {\n  CSSProperties,\n  DOMElement,\n  FunctionMaybe,\n  PropValueOrAccessor,\n} from \"../types/types\";\nimport {\n  isFunction,\n  isObject,\n  isString,\n  needsEncoding,\n  urlAttributes,\n} from \"../util\";\nimport { escape } from \"@thednp/domparser\";\n\n\n/**\n * Sets or removes an attribute with the specified or inferred namespace on an element.\n * @param element - The DOM element to modify.\n * @param key - The attribute name (e.g., 'stroke-width', 'xlink:href').\n * @param value - The attribute value; falsy values remove the attribute.\n */\nexport const setAttribute = (\n  element: Element,\n  key: string,\n  rawValue?: PropValueOrAccessor,\n) => {\n  const value = isFunction(rawValue) ? rawValue() : rawValue;\n  const attrKey = key.indexOf(\":\") > -1 ? key.replace(/^[^:]+:/, \"\") : key;\n  const attrNamespaces = {\n    // \"\": \"http://www.w3.org/1999/xhtml\", // HTMLElement\n    \"xlink:\": \"http://www.w3.org/1999/xlink\", // XLink attributes (e.g., xlink:href)\n    \"xml:\": \"http://www.w3.org/XML/1998/namespace\", // XML attributes (e.g., xml:lang)\n    \"xsi:\": \"http://www.w3.org/2001/XMLSchema-instance\", // XML Schema Instance (e.g., xsi:schemaLocation)\n  };\n\n  // Determine attribute namespace\n  let attrNS = element?.namespaceURI || null;\n  for (const [prefix, uri] of Object.entries(attrNamespaces)) {\n    if (key.startsWith(prefix)) {\n      attrNS = uri;\n      break;\n    }\n  }\n  attrNS = attrNS === \"http://www.w3.org/1999/xhtml\" ? null : attrNS;\n\n  if (value == null || value === false || value === \"\" || value === undefined) {\n    element.removeAttributeNS(attrNS, attrKey);\n    element.removeAttribute(key);\n  } else {\n    const t = typeof value;\n    const attrValue = value === true\n      ? \"\"\n      : t === \"number\"\n      ? String(value)\n      : !urlAttributes.includes(key)\n      ? escape(value as string)\n      : (needsEncoding(key, value as string)\n        ? encodeURI(value as string)\n        : value);\n\n    element.setAttributeNS(attrNS, attrKey, attrValue as string);\n  }\n};\n\nexport const getStyleObject = <T extends CSSProperties>(styleObject: T) => {\n  const output = {} as T;\n  let key: keyof T;\n  let value: T[keyof T];\n  for (const [objKey, rawValue] of Object.entries(styleObject)) {\n    key = objKey.split(/(?=[A-Z])/).join(\"-\").toLowerCase() as keyof T;\n    // allow state values in style object\n    value = (isFunction(rawValue) ? rawValue() : rawValue) as T[keyof T]\n    if (value) output[key] = value;\n  }\n  return output;\n};\n\n/**\n * Allows the \"framework\" to support CSS objects\n */\nexport const styleToString = (\n  styleValue?: FunctionMaybe<CSSProperties | string | null | undefined>,\n) => {\n  const styleVal = isFunction(styleValue) ? styleValue() : styleValue;\n  return typeof styleVal === \"string\"\n    ? styleVal\n    : isObject(styleVal)\n    ? Object.entries(getStyleObject(styleVal)).reduce(\n      (acc, [key, value]) => acc + key + \":\" + value + \";\",\n      \"\",\n    )\n    : \"\";\n};\n\nexport const style = (\n  target: DOMElement,\n  styleValue?: FunctionMaybe<CSSProperties | string | null | undefined>,\n) => {\n  const styleVal = isFunction(styleValue) ? styleValue() : styleValue;\n\n  if (isObject(styleVal)) {\n    const styleObject = getStyleObject(styleVal);\n    if (Object.values(styleObject).filter((v) => v).length) {\n      Object.assign(target.style, styleObject);\n    } else {\n      target.removeAttribute(\"style\");\n    }\n  } else if (isString(styleVal) && styleVal.length) {\n    target.style.cssText = styleVal;\n  } else {\n    target.removeAttribute(\"style\");\n  }\n};\n","export const namespaceElementsMap = {\n  \"http://www.w3.org/1999/xhtml\": [\n    // tags common with SVG\n    \"a\",\n    \"style\",\n    \"title\",\n    \"script\",\n    // \"abbr\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"bdi\", \"bdo\",\n    // \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\",\n    // \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"div\", \"dl\", \"dt\", \"em\", \"embed\",\n    // \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n    // \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"img\", \"input\", \"ins\", \"kbd\",\n    // \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"menu\", \"meta\", \"meter\", \"nav\",\n    // \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"pre\",\n    // \"progress\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"slot\",\n    // \"small\", \"source\", \"span\", \"strong\",\n    // \"sub\", \"summary\", \"sup\", \"table\", \"tbody\",\n    // \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\",\n    // \"tr\", \"track\", \"u\",\n    // \"ul\", \"var\", \"video\", \"wbr\"\n  ],\n  \"http://www.w3.org/2000/svg\": [\n    \"svg\",\n    \"a\",\n    \"animate\",\n    \"animateMotion\",\n    \"animateTransform\",\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\",\n    \"filter\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"mpath\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"set\",\n    \"stop\",\n    \"style\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textPath\",\n    \"title\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n  ],\n  \"http://www.w3.org/1998/Math/MathML\": [\n    \"math\",\n    \"maction\",\n    \"maligngroup\",\n    \"malignmark\",\n    \"menclose\",\n    \"merror\",\n    \"mfenced\",\n    \"mfrac\",\n    \"mglyph\",\n    \"mi\",\n    \"mlabeledtr\",\n    \"mmultiscripts\",\n    \"mn\",\n    \"mo\",\n    \"mover\",\n    \"mpadded\",\n    \"mphantom\",\n    \"mprescripts\",\n    \"mroot\",\n    \"mrow\",\n    \"ms\",\n    \"mspace\",\n    \"msqrt\",\n    \"mstyle\",\n    \"msub\",\n    \"msubsup\",\n    \"msup\",\n    \"mtable\",\n    \"mtd\",\n    \"mtext\",\n    \"mtr\",\n    \"munder\",\n    \"munderover\",\n    \"semantics\",\n    \"annotation\",\n    \"annotation-xml\",\n  ],\n};\n\n/**\n * Create reverse lookup for namespace elements\n */\nexport const namespaceElements: Record<string | symbol, string> = Object\n  .entries(\n    namespaceElementsMap,\n  ).reduce(\n    (acc, [namespace, elements]) => {\n      elements.forEach((element) => {\n        if (!(element in acc)) acc[element] = namespace;\n      });\n      return acc;\n    },\n    {} as Record<string | symbol, string>,\n  );\n","// src/h.ts\nimport { effect, untrack } from \"../core/state\";\nimport { setAttribute, style } from \"./attr\";\nimport { namespaceElements } from \"./ns\";\nimport type {\n  DOMElement,\n  DOMNodeAttributes,\n  FunctionMaybe,\n  MaybeChildNode,\n  OutputElement,\n  PotentialProps,\n  Primitive,\n  TagNames,\n} from \"../types/types\";\nimport {\n  getStringValue,\n  isArray,\n  isFunction,\n  isNode,\n  isObject,\n} from \"../util\";\nimport type { Accessor } from \"../types/types\";\n\n// Append children\nexport const add = (\n  parent: DOMElement,\n  child?:\n    | FunctionMaybe<RegExp | Date>\n    | Accessor<MaybeChildNode>\n    | MaybeChildNode\n    | Promise<MaybeChildNode>,\n) => {\n  if (!parent || !child) return;\n\n  if (child instanceof Promise) {\n    child.then((resolved) => add(parent, resolved));\n  } else if (isArray(child)) {\n    child.forEach((c) => add(parent, c));\n  } else if (isNode(child)) {\n    parent.appendChild(child);\n  } else if (isFunction(child)) {\n    const textNode = document.createTextNode(\"\");\n    parent.appendChild(textNode);\n    const realChild = (isFunction(untrack(child as Accessor<Accessor<unknown>>)) ? untrack(child as Accessor<Accessor<unknown>>) : child) as Accessor<\n      MaybeChildNode\n    >;\n\n    effect(() => {\n      const value = realChild();\n      if (isArray(value)) {\n        parent.textContent = \"\";\n        value.forEach((v) => add(parent, v));\n      } else if (isNode(value)) { // Node\n        add(parent, child);\n      } else { // string | number | bigint | boolean | symbol | Date | RegExp\n        textNode.textContent = getStringValue(\n          value as Primitive | RegExp | Date,\n        );\n      }\n    });\n  } else {\n    parent.appendChild(document.createTextNode(getStringValue(child)));\n  }\n};\n\nexport const createDomElement = <\n  K extends TagNames,\n  M = OutputElement<K>,\n>(tagName: K) => {\n  const ns = namespaceElements[tagName];\n  return (ns\n      ? document.createElementNS(ns, tagName)\n      : document.createElement(tagName)) as M;\n};\n\nexport function listen<K extends keyof HTMLElementEventMap>(\n  target: DOMElement,\n  event: K,\n  handler:\n    & EventListenerObject[\"handleEvent\"]\n    & ((e: HTMLElementEventMap[K]) => void),\n  options?: AddEventListenerOptions,\n) {\n  target.addEventListener(event, handler, options);\n}\n\nexport function h<K extends TagNames>(\n  tagName: K,\n  first?: MaybeChildNode | DOMNodeAttributes<PotentialProps<K>, K>,\n  ...children: MaybeChildNode[]\n): OutputElement<K> {\n  const element = createDomElement(tagName);\n\n  // Handle props if first is an object and not a Node\n  if (isObject(first) && !isNode(first) && !isArray(first)) {\n    Object.entries(first).forEach(([key, value]) => {\n      if (key.startsWith(\"on\")) {\n        if (typeof value !== \"function\") {\n          return;\n        }\n        const eventName = key.slice(2)\n          .toLowerCase() as keyof HTMLElementEventMap;\n        listen(element, eventName, value);\n      } else if (key === \"style\") {\n        effect(() => style(element, value));\n      } else {\n        effect(() => setAttribute(element, key, value));\n      }\n    });\n  } else {\n    add(element, first);\n  }\n\n  add(element, children);\n\n  return element;\n}\n","// router/routes.mjs\nimport type { RouteEntry } from \"./types\";\nexport const routes: RouteEntry[] = [];\n","// router/state.js\nimport { store } from \"../ssr/store\";\nimport { isServer } from \"../util\";\n\n/**\n * Fix the URL of a route\n */\nexport const fixRouteUrl = (url?: string) => {\n  if (!url) return \"/\";\n  if (url.startsWith(\"/\")) {\n    return url;\n  }\n  return `/${url}`;\n};\n\nconst initialPath = !isServer ? globalThis.location.pathname : \"/\";\nconst initialSearch = !isServer ? globalThis.location.search : \"\";\n\ntype RouterState = {\n  pathname: string;\n  searchParams: URLSearchParams,\n  params: Record<string, string>,\n}\n\n/**\n * The global router state.\n */\nexport const routerState = store<RouterState>({\n  pathname: initialPath,\n  searchParams: new URLSearchParams(initialSearch),\n  params: {},\n});\n\n/** */\nexport const setRouterState = (\n  path: string,\n  search?: string,\n  params?: Record<string, string>,\n) => {\n  const [pathname, searchParams] = fixRouteUrl(path).split(\"?\");\n  routerState.pathname = pathname;\n  routerState.searchParams = new URLSearchParams(\n    search || searchParams || \"\",\n  );\n  routerState.params = params || {};\n};\n","import { isServer } from \"../util\";\nimport { routerState } from \"../router/state\";\nimport type { ComponentFn, ComponentModule, LazyComponent } from \"../router/types\";\n\n/**\n * Check if selected page is the current page;\n */\nexport const isCurrentPage = (pageName: string) => {\n  return routerState.pathname === pageName;\n};\n\n/**\n * Check if component is a lazy component\n */\nexport const isLazyComponent = (\n  component: ComponentFn | (() => LazyComponent),\n): component is () => LazyComponent => {\n  // Server: Check if it's an async function\n  if (isServer && typeof component === \"function\") {\n    return component.constructor.name.includes(\"AsyncFunction\");\n  }\n\n  // Client: Check if it's designated as lazy\n  return (component as unknown as LazyComponent)?.isLazy === true;\n};\n\n/**\n * Execute lifecycle methods preload and / or load\n */\nexport const executeLifecycle = async (\n  { route }: ComponentModule,\n  params?: Record<string, string>,\n): Promise<boolean> => {\n  // istanbul ignore next\n  if (!route) return true;\n  try {\n    if (route?.preload) await route.preload(params);\n    if (route?.load) await route.load(params);\n    return true;\n  } catch (error) {\n    // istanbul ignore next\n    console.error(\"Lifecycle execution error:\", error);\n    // istanbul ignore next\n    return false;\n  }\n};\n\n/**\n * Client only reload utility\n * WORK IN PROGRESS\n * @param {boolean} forceFetch - Force fetch from server\n * @returns {void}\n */\n// export const reload = (forceFetch = false) => {\n//   if (!isServer) {\n//     // Client-side reload\n//     if (forceFetch) {\n//       window.location.reload();\n//     } else {\n//       // Soft reload - just update router state\n//       const { pathname, search } = window.location;\n//       setRouterState(pathname, search);\n//     }\n//   } else {\n//     // Server-side reload - throw error\n//     console.error(\"Reload is not supported on server\");\n//   }\n// };\n\n/**\n * Isomorphic redirect utility\n * WORK IN PROGRESS\n * @param {string} path - The path to redirect to\n * @param {object} options - Redirect options\n * @param {number} options.status - HTTP status code (server-side only)\n * @param {boolean} options.replace - Whether to replace current history entry (client-side only)\n * @returns {void}\n */\n// export const redirect = (path, options = {}) => {\n//   const { status = 302, replace = true } = options;\n\n//   if (!isServer) {\n//     // Client-side redirect\n//     navigate(path, { replace });\n//   } else {\n//     // Server-side redirect\n//     const error = new Error(`Redirect to ${path}`);\n//     error.status = status;\n//     error.location = path;\n//     throw error;\n//   }\n// };\n\n// Utility to handle server-side redirects in your server entry point\n// export const handleServerRedirect = (error, res) => {\n//   if (error.location && error.status) {\n//     res.writeHead(error.status, {\n//       Location: error.location,\n//       \"Content-Type\": \"text/plain\",\n//     });\n//     res.end(`Redirecting to ${error.location}...`);\n//     return true;\n//   }\n//   return false;\n// };\n","import type { ComponentModule, ImportFn } from \"./types\";\n\nconst routeCache = new Map<ImportFn, ComponentModule>();\n\nexport const getCached = (key: ImportFn) => routeCache.get(key);\nexport const cache = (key: ImportFn, value: ComponentModule) => {\n  routeCache.set(key, value);\n};\n","// router/lazy.mjs\n// import { signal } from \"../core/state\";\nimport { signal } from \"@core\";\nimport { isServer } from \"../util\";\nimport { cache, getCached } from \"./cache\";\nimport type { ComponentModule, ImportFn, LazyComponent } from \"./types\";\n\n/**\n * Registers a lazy component.\n */\nexport const lazy = (importFn: ImportFn) => {\n  if (isServer) {\n    return async () => {\n      const cached = getCached(importFn);\n      /* istanbul ignore next */\n      if (cached) {\n        return cached;\n      }\n\n      const module = await importFn();\n      const component = module?.default || module.Page;\n      const result = { component, route: module.route };\n\n      cache(importFn, result);\n      return result;\n    };\n  }\n\n  let initialized = false;\n  const [component, setComponent] = signal<\n    ComponentModule[\"component\"] | string\n  >(\"Loading..\");\n  const [route, setRoute] = signal<ComponentModule[\"route\"]>({});\n\n  const load = () => {\n    if (initialized) return;\n\n    const cached = getCached(importFn);\n    /* istanbul ignore next */\n    if (cached) {\n      setComponent(cached.component);\n      setRoute(cached.route);\n      return;\n    }\n\n    initialized = true;\n    importFn().then(\n      (module) => {\n        const pageComponent = module?.default || module.Page;\n        cache(importFn, { component: pageComponent, route: module.route });\n        setComponent(pageComponent);\n        setRoute(module.route);\n      },\n    );\n  };\n\n  const lazyComponent = () => {\n    load();\n    return { component: component(), route: route() };\n  };\n  lazyComponent.isLazy = true;\n\n  return lazyComponent as unknown as LazyComponent;\n};\n","// router/routes.mjs\nimport { isLazyComponent } from \"../helpers/router-helpers\";\nimport { routes } from \"./routes\";\nimport { lazy } from \"./lazy\";\nimport type { ComponentModule, RouteProps } from \"./types\";\n\n/**\n * Register a new Route entry\n */\nexport const Route = (routeProps: RouteProps) => {\n  const { path, component, preload, load, ...rest } = routeProps;\n\n  // istanbul ignore next - no point testing this error\n  if (routes.some((r) => r.path === path)) {\n    console.error(`  ➜  pakframe/router: duplicated route for \"${path}\".`);\n    return;\n  }\n\n  // If component isn't lazy, make it lazy\n  if (!isLazyComponent(component)) {\n    const wrappedComponent = lazy(() =>\n      Promise.resolve({\n        Page: component,\n        route: { preload, load },\n      })\n    );\n    routes.push({\n      ...rest,\n      path,\n      component: wrappedComponent as (() => Promise<ComponentModule>),\n    });\n    return;\n  }\n\n  // Otherwise keep original component\n  routes.push(routeProps);\n};\n","/**\n * Extract route params\n */\nexport const extractParams = (pattern: string, path: string) => {\n  const params: Record<string, string> = {};\n  const patternParts = pattern.split(\"/\");\n  const pathParts = path.split(\"/\");\n\n  if (patternParts.length !== pathParts.length) return null;\n\n  for (let i = 0; i < patternParts.length; i++) {\n    const patternPart = patternParts[i];\n    const pathPart = pathParts[i];\n\n    if (patternPart.startsWith(\":\")) {\n      params[patternPart.slice(1)] = pathPart;\n    } else if (patternPart !== pathPart) {\n      return null;\n    }\n  }\n\n  return params;\n};\n","// router/matchRoute.mjs\nimport { extractParams } from \"./extractParams\";\nimport { routes } from \"./routes\";\n\n/**\n * Find a registered route that matches the given path\n */\nexport const matchRoute = (initialPath: string) => {\n  const path = initialPath !== \"/\" && initialPath.endsWith(\"/\")\n    ? initialPath.slice(0, -1)\n    : initialPath;\n\n  // First try exact match (excluding wildcards)\n  let foundMatch = routes.find((r) => r.path === path && !r.path.includes(\"*\"));\n\n  // Then try nested wildcard match if no exact match found\n  if (!foundMatch) {\n    // Build the path for potential nested wildcard, e.g. /admin/* for /admin/articles\n    const nestedPath = path.split(\"/\").slice(0, -1).join(\"/\") + \"/*\";\n    foundMatch = routes.find((r) => r.path === nestedPath);\n  }\n\n  // If we found either an exact or nested wildcard match, return it with params\n  if (foundMatch) {\n    return {\n      ...foundMatch,\n      params: extractParams(foundMatch.path, path) ?? /* istanbul ignore next */\n        undefined,\n    };\n  }\n\n  // Try parameterized routes (like /users/:id)\n  for (const route of routes) {\n    // Skip the global catch-all\n    if (route.path === \"*\") continue;\n    const params = extractParams(route.path, path);\n\n    if (params) {\n      return { ...route, params };\n    }\n  }\n\n  // Finally, fallback to global catch-all route\n  return routes.find((r) => r.path === \"*\") || null;\n};\n","import { isServer } from \"../util\";\nimport { matchRoute } from \"./matchRoute\";\nimport { setRouterState } from \"./state\";\n\n/**\n * Client only navigation utility.\n */\nexport const navigate = (\n  path: string,\n  options: { replace: boolean } = { replace: false },\n) => {\n  const { replace = false } = options;\n\n  // istanbul ignore else\n  if (!isServer) {\n    // Client-side navigation\n    const url = new URL(path, globalThis.location.origin);\n    const route = matchRoute(url.pathname);\n\n    // Update history\n    if (replace) {\n      globalThis.history.replaceState({}, \"\", path);\n    } else {\n      globalThis.history.pushState({}, \"\", path);\n    }\n\n    // Update router state\n    setRouterState(url.pathname, url?.search, route?.params);\n  } else {\n    // Server-side navigation - throw error\n    console.error(\"  ➜  Direct navigation is not supported on server\");\n  }\n};\n","// router/a.mjs\n// import { effect, h } from \"../core/index\";\nimport { effect, h } from \"@core\";\nimport { matchRoute } from \"./matchRoute\";\nimport { executeLifecycle, isCurrentPage } from \"../helpers/router-helpers\";\nimport { navigate } from \"./navigate\";\nimport type {\n  DOMNodeAttributes,\n  DOMTagNameMap,\n  MaybeChildNode,\n} from \"../types/types\";\n\ntype AnchorProps =\n  & Omit<DOMNodeAttributes<DOMTagNameMap[\"a\"], \"a\">, \"children\">\n  & {\n    children?: MaybeChildNode[];\n  };\n\n/** */\nexport const A = (\n  /* istanbul ignore next */ { href, children, ...rest }: AnchorProps = {},\n  ...otherChildren: MaybeChildNode[]\n) => {\n  /* istanbul ignore next - try again later */\n  const props = Object.fromEntries(\n    Object.entries(rest || {}).filter(([_, val]) => val !== undefined),\n  ) as Omit<DOMNodeAttributes<DOMTagNameMap[\"a\"], \"a\">, \"children\" | \"href\">;\n  const newProps: Omit<DOMNodeAttributes<DOMTagNameMap[\"a\"], \"a\">, \"children\"> =\n    {\n      href,\n      ...props,\n      onclick: async (e: MouseEvent) => {\n        e.preventDefault();\n        const HREF = (typeof href === \"function\" ? href() : href) as string;\n        /* istanbul ignore next */\n        if (isCurrentPage(HREF)) return;\n\n        // istanbul ignore else\n        if (typeof props.onclick === \"function\") {\n          props.onclick(e);\n        }\n\n        const route = matchRoute(HREF)!;\n        const module = await route.component();\n        await executeLifecycle(module, route.params);\n\n        navigate(HREF);\n      },\n      onmouseenter: () => {\n        const HREF = (typeof href === \"function\" ? href() : href) as string;\n\n        const route = matchRoute(HREF);\n\n        /* istanbul ignore else */\n        if (route?.component) {\n          route.component();\n        }\n      },\n    };\n\n  effect(() => {\n    const HREF = (typeof href === \"function\" ? href() : href) as string;\n\n    if (isCurrentPage(HREF)) {\n      newProps[\"aria-current\"] = \"page\";\n    }\n  });\n\n  return h(\"a\", newProps, children || otherChildren);\n};\n","import type { DOMElement, FunctionMaybe, MaybeChildNode } from \"../types/types\";\nimport { isArray, isFunction } from \"../util\";\n\n/**\n * Merge the children of an Element or an array of elements with an optional array of children\n * into the childen prperty of a simple object.\n */\nexport const unwrap = (\n  source: FunctionMaybe<DOMElement | DOMElement[]>,\n  ...children: MaybeChildNode[]\n) => {\n  const layout = () => {\n    const pageChildren =\n      source && typeof source === \"object\" && \"children\" in source &&\n        isArray(source?.children)\n        ? source.children as DOMElement[]\n        : isFunction(source)\n        ? [\n          ...(source as () => DOMElement)().children ||\n            (source as () => DOMElement[])(),\n        ]\n        : typeof HTMLElement !== \"undefined\" && source instanceof HTMLElement\n        ? [...source.children] as DOMElement[]\n        : /* istanbul ignore next */ isArray(source)\n        ? source as DOMElement[]\n        : [source];\n\n    return {\n      children: [\n        ...(children || /* istanbul ignore next */ []),\n        ...pageChildren,\n      ],\n    };\n  };\n  return layout();\n};\n","export const parseAttributes = (attributeString: string) => {\n  const attributes: Record<string, string> = {};\n  const attributeRegex = /([a-zA-Z0-9_-]+)(?:=\"([^\"]*?)\")?/g;\n  let match;\n\n  while ((match = attributeRegex.exec(attributeString)) !== null) {\n    const name = match[1];\n    const value = match[2] || /* istanbul ignore next */ \"\";\n    attributes[name] = value;\n  }\n\n  return attributes;\n};\n\nconst getTagAttribute = (tag: Element) => {\n  const attributes = [\n    \"name\",\n    \"property\",\n    \"charset\",\n    \"viewport\",\n    \"media\",\n    \"http-equiv\",\n    \"rel\",\n    \"src\",\n    \"href\",\n    \"id\",\n  ];\n\n  for (const attr of attributes) {\n    const value = tag.getAttribute(attr);\n\n    if (value) return value;\n  }\n  return \"\";\n};\n\nexport const getTagKey = (tag: Element) => {\n  return tag.tagName +\n    (tag.tagName !== \"TITLE\" ? `.${getTagAttribute(tag)}` : \"\");\n};\n","import { isServer } from \"../util\";\nimport { getTagKey } from \"../helpers/head-helpers\";\nimport type { SupportedHeadTags } from \"./types\";\n\n/**\n * Create a new Map for each request on server\n */\nconst createHeadTags = () => new Map<string, SupportedHeadTags>();\n\n/**\n * Get the current head tags. Use a factory pattern to get the right store\n * on the server and the client.\n */\nconst getHeadTags = (() => {\n  if (isServer) {\n    // On server, create one Map per request scope\n    let serverHeadTags: Map<string, SupportedHeadTags>;\n    return () => {\n      if (!serverHeadTags) {\n        serverHeadTags = createHeadTags();\n      }\n      return serverHeadTags;\n    };\n  }\n  // On client, use a singleton\n  const clientHeadTags = createHeadTags();\n  return () => clientHeadTags;\n})();\n\n/**\n * Clear all head tags\n */\nexport const resetHeadTags = () => {\n  const tags = getHeadTags();\n  tags.clear();\n};\n\n/**\n * Initialize the head tags\n */\nexport const initializeHeadTags = () => {\n  const tags = getHeadTags();\n  /* istanbul ignore else */\n  if (!tags.size && !isServer) {\n    Array.from(document.head.children).forEach((tag) => {\n      tags.set(getTagKey(tag), tag as SupportedHeadTags);\n    });\n  }\n};\n\n/**\n * Add a new meta tag\n */\nexport const addMeta = (tag: SupportedHeadTags) => {\n  if (!tag) return;\n  const tags = getHeadTags();\n  const key = getTagKey(tag);\n  tags.set(key, tag);\n};\n\n/**\n * Get the head tags\n */\nexport const Head = () => {\n  // return () => {\n  const tags = getHeadTags();\n  return Array.from(tags.values());\n  // };\n};\n","import { h } from \"@core\";\nimport type { DOMNodeAttributes, PotentialProps } from \"../types/types\";\nimport { addMeta } from \"./Head\";\n\n/**\n * Add a new `<title>` tag\n */\nexport const Title = (\n  props: DOMNodeAttributes<PotentialProps<\"title\">, \"title\">,\n  content: string,\n) => {\n  addMeta(h(\"title\", props, content));\n  return null;\n};\n\n/**\n * Add a new `<meta>` tag\n */\nexport const Meta = (props: DOMNodeAttributes<PotentialProps<\"meta\">, \"meta\">) => {\n  addMeta(h(\"meta\", props));\n  return null;\n};\n\n/**\n * Add a new `<link>` tag\n */\nexport const Link = (props: DOMNodeAttributes<PotentialProps<\"link\">, \"link\">) => {\n  addMeta(h(\"link\", props));\n  return null;\n};\n\n/**\n * Add a new `<script>` tag\n */\nexport const Script = (\n  props: DOMNodeAttributes<PotentialProps<\"script\">, \"script\">,\n  content: string,\n) => {\n  addMeta(h(\"script\", props, content));\n  return null;\n};\n\n/**\n * Add a new `<style>` tag\n */\nexport const Style = (\n  props: DOMNodeAttributes<PotentialProps<\"style\">, \"style\">,\n  content: string,\n) => {\n  addMeta(h(\"style\", props, content));\n  return null;\n};\n","// import { add, effect, h, memo } from \"../core/index\";\nimport { add, effect, h, memo } from \"@core\";\nimport type { DOMElement, MaybeChildNode } from \"../types/types\";\nimport { isServer } from \"../util\";\nimport { routerState, setRouterState } from \"./state\";\nimport { matchRoute } from \"./matchRoute\";\nimport { executeLifecycle } from \"../helpers/router-helpers\";\nimport { unwrap } from \"./unwrap\";\nimport { hydrate } from \"../core/hydrate\";\nimport { Head, initializeHeadTags } from \"../meta\";\n\n// @ts-expect-error - typescript may never know what's this\nimport \"virtual:@pakframe/routes\";\n// import \"@pakframe/fs-routes\";\n\nlet isConnected = false;\n\nexport const Router = (initialProps = /* istanbul ignore next */ {}) => {\n  // const { div, main } = van.tags;\n\n  /* istanbul ignore next - try again later */\n  const props = Object.fromEntries(\n    Object.entries(initialProps).filter(([_, val]) => val !== undefined),\n  );\n  const wrapper = h(\"main\", { ...props, \"data-root\": true });\n  const mainLayout = () => {\n    const route = matchRoute(routerState.pathname);\n    /* istanbul ignore else */\n    if (!route) {\n\t\t\tadd(wrapper, h(\"div\", \"No Route Found\"));\n\t\t\treturn wrapper;\n\t\t}\n\n    routerState.params = route.params || {};\n    // Server-side or async component: use renderComponent\n    if (isServer) {\n      const renderComponent = async () => {\n        try {\n          const module = await route.component();\n          const component = typeof module.component === \"function\"\n            ? module.component()\n            : /* istanbul ignore next */ module.component;\n\n          await executeLifecycle(module, route.params);\n          add(wrapper, unwrap(component).children as MaybeChildNode[]);\n          return wrapper;\n        } catch (error) {\n          /* istanbul ignore next */\n          console.error(\"  ➜  Router error:\", error);\n          /* istanbul ignore next */\n          add(wrapper, h(\"div\", \"Error loading page\"));\n          return wrapper;\n        }\n      };\n\n      return renderComponent();\n    }\n\n    const root = document.querySelector(\"[data-root]\");\n    // istanbul ignore else - cannot test unmount\n    if (!isConnected || !root) {\n      initializeHeadTags();\n      globalThis.addEventListener(\n        \"popstate\",\n        // istanbul ignore next - cannot test\n        (e: Event) => {\n          const location = (e.target as Window)?.location;\n          const oldPath = routerState.pathname;\n          // istanbul ignore next - cannot test\n          if (location.pathname !== oldPath) {\n            setRouterState(location.pathname, location.search);\n          }\n        },\n      );\n    }\n\n    // Client-side lazy component, lifeCycle is already executed on the server\n    // or when A component has been clicked in the client\n    if (root) {\n      // this case is when root is server side rendered\n      const children = async () => {\n        const module = await route.component();\n        executeLifecycle(module, route.params);\n        // istanbul ignore next - cannot test\n        const cp = (Array.isArray(module) || module instanceof Element)\n          ? module as DOMElement[]\n          : typeof module.component === \"function\"\n          ? module.component()\n          : module.component;\n        // istanbul ignore next - cannot test\n        const kids = () => cp ? Array.from(unwrap(cp).children) : [];\n        const kudos = kids();\n\n        isConnected = true;\n        // istanbul ignore else\n        if (document.head) {\n          hydrate(document.head, Head());\n        }\n\n        return kudos;\n      };\n\n      return add(wrapper, children() as Promise<MaybeChildNode>);\n    }\n    // this case is when root is for SPA apps\n    const csrRoute = memo(() => {\n      const p = routerState.pathname;\n      return matchRoute(p);\n    });\n\n    const children = memo(() => {\n      const route = csrRoute();\n      // istanbul ignore if - can only be tested in client\n      if (!route) return [h(\"div\", \"No Route Found\")];\n      const md = route.component();\n      executeLifecycle(md, route.params);\n      // istanbul ignore next - cannot test all cases\n      const cp = (Array.isArray(md) || md instanceof Element)\n        ? md\n        : typeof md.component === \"function\"\n        ? md.component()\n        : md.component;\n      return cp\n        ? Array.from(unwrap(cp).children)\n        : /* istanbul ignore next */ [];\n    });\n\n    const component = () => {\n      const kids = children();\n      const result = () => {\n        return memo(() =>\n          hydrate(wrapper, (el) => {\n            const kudos = kids;\n            isConnected = true;\n            // istanbul ignore else\n            // if (document.head) {\n            //   hydrate(document.head, (head) => hydrate(head, Head()));\n            // }\n            return hydrate(el, kudos);\n          })\n        );\n      };\n      return result();\n    };\n    const finalResult = component();\n    if (finalResult) add(wrapper, finalResult)\n    \n    return wrapper;\n  };\n\n  return mainLayout();\n};\n","import { unwrap } from \"../router/index\";\nimport { getTagKey } from \"../meta\";\nimport type { DOMElement } from \"../types/types\";\n\nconst isTag = (target: DOMElement, ...tagNames: string[]) => {\n  return tagNames.some((tag) =>\n    target.tagName.toLowerCase() === tag.toLowerCase()\n  );\n};\n\nconst hasHydrationKeys = (target: Element) => {\n  return target.querySelector(\"[data-hk]\") !== undefined;\n}\n\n/**\n * Hydrate a target element\n */\nexport const hydrate = (\n  target: DOMElement,\n  content: DOMElement | DOMElement[] | Promise<DOMElement | DOMElement[]>,\n) => {\n  if (content instanceof Promise) {\n    content.then((res) => {\n      if (!target.hasAttribute(\"data-h\")) {\n        hydrate(target, res);\n      } else {\n        const wrapper = unwrap(res);\n        target.replaceChildren(\n          ...(Array.from(wrapper.children) as (DOMElement | Text)[]),\n        );\n      }\n    });\n    return target;\n  }\n\n  const wrapper = unwrap(content);\n  const currentChildren = Array.from(target.children);\n  const newChildren = wrapper.children as (DOMElement )[];\n\n  if (isTag(target, \"head\")) {\n    // Keep current tags on first hydration\n    if (!target.hasAttribute(\"data-h\")) {\n      target.setAttribute(\"data-h\", \"\");\n      return target;\n    }\n\n    // Handle non-style/link tags first\n    const regularTags = (newChildren as DOMElement[]).filter((child) =>\n      !isTag(child, \"style\", \"link\")\n    );\n\n    // Handle style/link tags separately\n    const styleTags = (newChildren as DOMElement[]).filter((child) =>\n      isTag(child, \"style\", \"link\")\n    );\n\n    // Create maps for existing tags\n    const existingStyles = new Map(\n      (currentChildren as DOMElement[]).filter((child) => isTag(child, \"style\", \"link\"))\n        .map((child) => [getTagKey(child), child]),\n    );\n\n    // Process regular tags normally\n    regularTags.forEach((newChild) => {\n      const key = getTagKey(newChild);\n      const existing = currentChildren.find((child) =>\n        getTagKey(child) === key\n      );\n      if (existing) {\n        existing.replaceWith(newChild);\n      } else {\n        target.appendChild(newChild);\n      }\n    });\n\n    // Process style tags with special handling\n    styleTags.forEach((newChild) => {\n      const key = getTagKey(newChild);\n      const existing = existingStyles.get(key);\n\n      // Skip if tag already exists with same content+id/href\n      if (existing) {\n        // istanbul ignore next - try again later\n        if (isTag(existing, \"style\") && isTag(newChild, \"style\")) {\n          if (\n            existing.textContent === newChild.textContent &&\n            existing.id === newChild.id\n          ) return;\n        }\n        // istanbul ignore next - try again later\n        if (isTag(existing, \"link\") && isTag(newChild, \"link\")) {\n          if (\n            (existing as HTMLAnchorElement).href ===\n              (newChild as HTMLAnchorElement).href\n          ) return;\n        }\n      }\n\n      // For link tags, add with disabled state first\n      // istanbul ignore else - try again later\n      if (isTag(newChild, \"link\")) {\n        const temp = newChild.cloneNode() as HTMLLinkElement;\n        temp.disabled = true;\n\n        const originalRel = temp.rel;\n        temp.rel = \"preload\";\n        temp.as = \"style\";\n        // istanbul ignore next\n        temp.onload = () => {\n          temp.rel = originalRel;\n          temp.removeAttribute(\"as\");\n          temp.disabled = false;\n          if (existing && existing.parentNode === target) {\n            existing.remove();\n          }\n        };\n\n        target.appendChild(temp);\n      } // For style tags, add new one first\n      else if (isTag(newChild, \"style\")) {\n        target.appendChild(newChild);\n        // istanbul ignore next - try again later\n        if (existing && existing.parentNode === target) {\n          // Remove old one in next frame\n          existing.remove();\n        }\n      }\n    });\n  } else {\n    //  Handle Initial Hydration\n    if (!target.hasAttribute(\"data-h\")) {\n      if (hasHydrationKeys(target) && currentChildren.length === newChildren.length) {\n        currentChildren.forEach((child, i) => {\n          child.replaceChildren(...Array.from(newChildren[i].childNodes))\n        });\n      }\n      else target.replaceChildren(...newChildren);\n      target.setAttribute(\"data-h\", \"\");\n    //  Handle Subsequent Hydration\n    } else {\n      target.replaceChildren(...newChildren);\n    }\n  }\n\n  return target;\n};\n","import { signal } from \"./state\";\nimport type { Accessor, Primitive, Setter, StoreObject } from \"../types/types\";\nimport { isArray, isFunction, isPlainObject } from \"../util\";\n\nfunction processArrayItem(item: Primitive | StoreObject) {\n  if (!isPlainObject(item) || item && item[\"_\"]) return item;\n  if (isPlainObject(item)) {\n    const newObj = {} as StoreObject;\n    createState(item, newObj);\n    Object.defineProperty(newObj, \"_\", { value: true, enumerable: false });\n    return newObj;\n  }\n  return item;\n}\n\nfunction createArrayProxy(\n  get: Accessor<(Primitive | StoreObject)[]>,\n  set: Setter<(Primitive | StoreObject)[]>,\n) {\n  return new Proxy<(Primitive | StoreObject)[]>([], {\n    get(_, prop) {\n      const arr = get();\n      const typedProp = prop as keyof typeof Array.prototype | number;\n      // Apply Array prototype methods\n      if (isFunction(Array.prototype[typedProp])) {\n        return (...args: Array<StoreObject>) => {\n          const result = Array.prototype[typedProp].apply(arr, args);\n          if (\n            [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].includes(String(prop))\n          ) {\n            set(arr.map(processArrayItem));\n          }\n          return result;\n        };\n      }\n      // Access Array items\n      return arr[typedProp];\n    },\n  });\n}\n\nfunction reconcileArrays(\n  current: Array<Primitive | StoreObject>,\n  next: Array<Primitive | StoreObject>,\n) {\n  if (next.length !== current.length) return next.map(processArrayItem);\n  return next.some((item, i) => item !== current[i])\n    ? next.map(processArrayItem)\n    : current;\n}\n\nfunction createState(obj: StoreObject, parentReceiver: StoreObject) {\n  for (const [key, value] of Object.entries(obj)) {\n    if (isArray(value)) {\n      const [get, set] = signal<(Primitive | StoreObject)[]>(\n        value.map(processArrayItem),\n      );\n      const proxy = createArrayProxy(get, set);\n\n      Object.defineProperty(parentReceiver, key, {\n        get: () => proxy,\n        set: (newValue) => {\n          const reconciledArray = reconcileArrays(proxy, newValue);\n          if (reconciledArray !== proxy) set(reconciledArray);\n          return true;\n        },\n        enumerable: true,\n      });\n    } else if (isPlainObject(value)) {\n      parentReceiver[key] = createState(value, {});\n    } else {\n      const [get, set] = signal(value);\n      Object.defineProperty(parentReceiver, key, { get, set });\n    }\n  }\n  return parentReceiver;\n}\n\nexport function store<T extends StoreObject>(init: T) {\n  return createState(init, {}) as T;\n}\n","// src/flow.ts\nimport type { DOMElement, FunctionMaybe, MaybeChildNode } from \"../types/types\";\nimport { effect, untrack } from \"./state\";\nimport { isArray, isFunction } from \"../util\";\n\nexport type ListProps<T> = {\n  each?: () => T[];\n  children?: (item: T) => MaybeChildNode;\n};\n\nexport const List = <T>(props: ListProps<T>) => {\n  const { each, children } = props;\n\tlet parentElement: DOMElement;\n  const placeholder = document.createTextNode(\"\");\n  const itemMap = new Map<T, DOMElement>();\n  const updateItems = (items: T[]) => {\n    let marker: DOMElement | Text = placeholder;\n    if (!children || !parentElement) return;\n\n    for (const item of items) {\n      if (!itemMap.has(item)) {\n        const node = children(item) as DOMElement;\n        if (node) {\n          marker.after(node);\n          itemMap.set(item, node);\n        }\n      }\n      marker = itemMap.get(item) ?? placeholder;\n    };\n  }\n\n  effect(() => {\n    const items = each ? each() : [];\n\n    for (const [item, node] of itemMap) {\n      if (!items.includes(item)) {\n        node.remove();\n        itemMap.delete(item);\n      }\n    }\n    updateItems(items)\n  });\n\n  queueMicrotask(() => {\n    parentElement = placeholder.parentElement as DOMElement;\n    if (isFunction(each)) {\n      updateItems(untrack(each))\n    }\n  });\n\n  return placeholder as unknown as DOMElement[];\n};\n\nexport function Show<T>({\n  when,\n  children,\n}: {\n  when: FunctionMaybe<T | boolean>;\n  children: MaybeChildNode;\n}) {\n  const placeholder = document.createTextNode(\"\");\n\tconst initialWhen = () => isFunction(when) ? when() : when;\n\tconst newNodes = () => {\n\t\tconst nodes = isFunction(children) ? children() : children;\n\t\treturn isArray(nodes) ? nodes : [nodes];\n\t};\n\n  effect(() => {\n\t\tconst condition = initialWhen();\n\t\tconst nodes = newNodes();\n\t\tconst nextElementSibling = placeholder.nextElementSibling;\n\t\tif (condition && (!nextElementSibling || nextElementSibling !== nodes[0])) {\n\t\t\tplaceholder.after(...nodes as DOMElement[]);\n\t\t} else if (!condition && placeholder.nextElementSibling === nodes[0]) {\n\t\t\tnodes.forEach((node) => (node as DOMElement).remove());\n\t\t}\n\t});\n\n  return placeholder as unknown as MaybeChildNode;\n}\n"],"mappings":"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ACnBC,QACAD,eACG;CACH,MAAM,WAAW,yBAAW,WAAW,GAAG,YAAY,GAAG;AAEzD,KAAI,uBAAS,SAAS,EAAE;EACtB,MAAM,cAAc,eAAe,SAAS;AAC5C,MAAI,OAAO,OAAO,YAAY,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,OAC9C,QAAO,OAAO,OAAO,OAAO,YAAY;MAExC,QAAO,gBAAgB,QAAQ;CAElC,WAAU,uBAAS,SAAS,IAAI,SAAS,OACxC,QAAO,MAAM,UAAU;KAEvB,QAAO,gBAAgB,QAAQ;AAElC;;;;ACjHD,MAAa,uBAAuB;CAClC,gCAAgC;EAE9B;EACA;EACA;EACA;CAcD;CACD,8BAA8B;EAC5B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;CACD;CACD,sCAAsC;EACpC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;CACD;AACF;;;;AAKD,MAAaE,oBAAqD,OAC/D,QACC,qBACD,CAAC,OACA,CAAC,KAAK,CAAC,WAAW,SAAS,KAAK;AAC9B,UAAS,QAAQ,CAAC,YAAY;AAC5B,QAAM,WAAW,KAAM,KAAI,WAAW;CACvC,EAAC;AACF,QAAO;AACR,GACD,CAAE,EACH;;;;ACnHH,MAAa,MAAM,CACjBC,QACAC,UAKG;AACH,MAAK,WAAW,MAAO;AAEvB,KAAI,iBAAiB,QACnB,OAAM,KAAK,CAAC,aAAa,IAAI,QAAQ,SAAS,CAAC;UACtC,sBA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"}